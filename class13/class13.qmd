---
title: "Class 13: RNASeq with DESeq2"
author: "Jacob Hizon A17776679"
format: pdf
toc: TRUE
---

## Background 
Today we will perform an RNASeq analysis of the effects of a common steroid on airway cells. 

In particular, dexamethasone (hereafter just called "dex") on different airway smooth muscle cell lines (ASN cells). 

## Data Import 

We need two different inputs: 

- **countData**: with genes in rows and experiments in columns  
- **colData**: meta data that describes the columns in the contData 

```{r}

counts <- read.csv("airway_scaledcounts.csv", row.names=1)
metadata <-  read.csv("airway_metadata.csv")
```

A peak at the counts and metadata 
```{r}
head(counts)
```
```{r}
metadata
```
> Q1. How many genes are in this dataset? 

```{r}
nrow(counts)
```


> Q2. How many ‘control’ cell lines do we have?

```{r}
table(metadata$dex)
```

## Differential Gene Expression 


We have 4 replicate drug treated and control (no drug) columns/experiments in our `counts` object. 

We want one "mean" value for each gene (rows) in "treated" (drug) and one mean value for each gene in "control" cols. 


Step 1. Find all "control" columns 

```{r}
control.inds <- metadata$dex == "control"
```

Step 2. Extract these columns to a new object called `control.counts` 

```{r}
control.counts <- counts[, control.inds]
```

Step 3. Then calculate the mean for each gene 

```{r}
control.mean <- rowMeans(control.counts)
```

```{r}
#library(dplyr)
#control <- metadata %>% filter(dex=="control")
#control.counts <- counts %>% select(control$id) 
#control.mean <- rowSums(control.counts)/4
#head(control.mean)
```

> Q3. How would you make the above code in either approach more robust? Is there a function that could help here?

You can make the code above more robust by using rowMeans() (or ncol(). 



> Q4. Now do the same thing for the "treated" / Follow the same procedure for the treated samples (i.e. calculate the mean per gene across drug treated samples and assign to a labeled vector called treated.mean)

Step 1. Find all "treated" columns 

```{r}
treated.inds <- metadata$dex == "treated"
```

Step 2. Extract these columns to a new object called `treated.counts` 

```{r}
treated.counts <- counts[, treated.inds]
```

Step 3. Then calculate the mean for each gene 

```{r}
treated.mean <- rowMeans(treated.counts)
```

Put these together for easy book-keeping as `meancounts`
```{r}
meancounts <- data.frame(control.mean, treated.mean)
```

> Q6. 

`log=` allows us to see the graph log transformed in base R. 

A quick plot
```{r}
plot(meancounts)
```

Let's log transform this data: 

```{r}
plot(meancounts, log="xy")
```
```{r}
plot(meancounts[,1],meancounts[,2], xlab="Control", ylab="Treated")
```

> Q5. (b)

Use geomp_point()


```{r}
library(ggplot2)

ggplot(meancounts, aes(x = control.mean, y = treated.mean)) +
  geom_point() +
  xlab("control.mean") +
  ylab("treated.mean")
```

**N.B.** We most often use log2 for this type of data as it makes the interpretation much more straightfoward. 

Treated/Control is often called "fold-change" 

If there were no change, we would have a log2-fc of zero: 
```{r}
log2(10/10)
```
If we had double the transcript around we would have a log2-fc of one 
```{r}
log2(20/10)
```
If we had half as much transcript around we would have a log2-fc of -1
```{r}
log2(5/10)
```

> Q. Calculate a log2 fold change value for all our genes and add it as a new column to our `meancounts` object 

```{r}
meancounts$log2fc <- log2(meancounts$treated.mean / 
                            meancounts$control.mean)
head(meancounts)
```
```{r}
zero.vals <- which(meancounts[,1:2]==0, arr.ind=TRUE)

to.rm <- unique(zero.vals[,1])
mycounts <- meancounts[-to.rm,]
head(mycounts)
```
> Q7. What is the purpose of the arr.ind argument in the which() function call above? Why would we then take the first column of the output and need to call the unique() function?

The arr.ind = TRUE argument returns a 2-column matrix of positions—the row index and column index—for every place where the condition is TRUE which in this case is where meancounts[,1:2] == 0). That tells us which genes (rows) have zeros and whether it was in control or treated (columns).

zero.vals[, 1] is then used because we only care about which rows/genes should be removed (a gene should be removed if it has a zero in either group). Finally,unique() is used because the same gene could have zeros in both columns. Twice—unique() ensures we only list each row once before taking them out. 


```{r}
up.ind <- mycounts$log2fc > 2
down.ind <- mycounts$log2fc < (-2)
```


> Using the up.ind vector above can you determine how many up regulated genes we have at the greater than 2 fc level? 

```{r}
sum(up.ind, na.rm = TRUE)
```

> Q9. Using the down.ind vector above can you determine how many down regulated genes we have at the greater than 2 fc level? 

```{r}
sum(down.ind, na.rm = TRUE)
```

> Q10. Do you trust these results? Why or why not?

Not really because this ‘toy’ approach compares raw mean counts between groups without using an actual statistical model. It does not account for important considerations such as library size/sequencing depth differences. There are also many zero-count genes that can distort fold changes and failure to remove them can cause discrepencies with the downstream analsyis.


```{r}
log2(40/10)
```

There are some "funky" log2fc values (NaN and -Inf) here that come about whenever we have 0 mean count values. Typically, we would remove these genes from any further analysis - as we can't CONT.


## DESeq analysis 

Let's do this analysis with an estimate of statistical significance using the **DESeq2** package 

```{r, message=FALSE}
library(DESeq2)
```

DESeq (like many bioconductor packages) want it's input data in a very specific way. 

```{r}
dds <- DESeqDataSetFromMatrix(countData = counts,
                       colData = metadata,
                       design = ~dex)
```

## Run the DESeq analysis pipline

The main function `DESeq()`
```{r}
dds <- DESeq(dds)
res <- results(dds)
head(res)
```

padj is more stringent and more strict than a normal p-value. This is important for larger data sets with many genes/data points


## Volcano Plot 

This is a main summary results figure from these kinds of studies. It is a plot of log2 fold-change vs (Adjusted) P-value. 

```{r}
plot(res$log2FoldChange, 
     res$padj)
```

Again this y-axis needs to be log-transformed. We can flip the y-axis with a minus sign so it looks like every other volcano plot. 

```{r}
plot(res$log2FoldChange,
     -log(res$padj))
abline(v=-2, col="red")
abline(v=+2, col="red")
abline(h=-log(0.05), col="red")
```

## Adding some color annotation 

Let's start with a default base color "gray"

```{r}
# Custom colors
mycols <- rep("gray", nrow(res))
mycols[res$log2FoldChange > 2] <- "blue"
mycols[res$log2FoldChange < -2] <- "darkgreen"
mycols[res$padj >=0.05] <- "gray"

# Volcano plot 
plot(res$log2FoldChange,
     -log(res$padj),
     col=mycols)
#cut off dashed lines
abline(v=-2, lty = 2)
abline(v=+2, lty = 2)
abline(h=-log(0.05), lty = 2)
```

> Q. Make a ggplot version of this plot  

```{r}
library(ggplot2)
#ggplot(res, aes(res$log2FoldChange,-log(res$padj))) +
 # geom_point(colour = mycols) +
 # labs (x="Log2 Fold-change",
    #    y= "-log Adjusted P-value") +
#  geom_vline(xintercept = c(-2,2)) +
 # geom_vline(yintercept=-log(0.05)) +
# theme_bw()
```

## Save our results 

Write a CSV file

```{r}
write.csv(res, file="results.csv")
```



## Add annotation data 

We need to add missing annotation data to our main `res` results object. This includes the common gene "symbol"

```{r}
head(res)
```

We will use R and bioconductor to do this "ID mapping" 


```{r}
library("AnnotationDbi")
library("org.Hs.eg.db")
```

Let's see what databases we can use for translation/mapping

```{r}
columns(org.Hs.eg.db)
```

We can use the `mapIds()` function to now "translate" between any of these databases. 

```{r}
res$symbol <- mapIds(org.Hs.eg.db,
                    keys=row.names(res),      # Our genenames
                    keytype="ENSEMBL",        # The format of our genenames
                    column="SYMBOL",)         # The new format we want to add

```
> Q11. Run the mapIds() function two more times to add the Entrez ID and UniProt accession and GENENAME as new columns called res$entrez, res$uniprot and res$genename.

> Q. Also add "ENTREZID", "GENENAME" 

```{r}
head(res)
```
```{r}
res$entrez <- mapIds(org.Hs.eg.db,
                    keys=row.names(res),      # Our genenames
                    keytype="ENSEMBL",        # The format of our genenames
                    column="ENTREZID",)         # The new format we want to add
```

```{r}
res$genename <- mapIds(org.Hs.eg.db,
                    keys=row.names(res),      # Our genenames
                    keytype="ENSEMBL",        # The format of our genenames
                    column="GENENAME",)         # The new format we want to add
```

```{r}
head(res)
```

## Save annotated results to a CSV file 

```{r}
write.csv(res, file = "results_annotated.csv")
```

## Pathway analysis 


What known biological pathways do our differential expressed genes genes overlap (i.e. play a role in)?


There's lots of bioconductor packages to do this type of analysis.

We will use one of the oldest called **gage** along with **pathviewer** to render nice pics of the pathways we find.

We can install these with the command:

`BiocManager::install( c("pathview", "gage", "gageData") )`

```{r, message=FALSE}
library(pathview)
library(gage)
library(gageData)
```

Have a peak what is in `gageData`

```{r}
# Examine the first 2 pathways in this kegg set for humans
data(kegg.sets.hs)
head(kegg.sets.hs, 2)
```
The main `gage()`function that does the actual work wants a simple vector as input.


```{r}
foldchanges <- res$log2FoldChange
names(foldchanges) <- res$symbol
head(foldchanges)
```

The KEGG database uses ENTREZ ids so we need to provide these in our input vector for **gage**:


```{r}
names(foldchanges) <- res$entrez
```

```{r}
# Get the results
keggres = gage(foldchanges, gsets=kegg.sets.hs)
```
What is in the output object `keggres` 

```{r}
attributes(keggres)

```

```{r}
# Look at the first three down (less) pathways
head(keggres$less, 3)
```
We can use the **pathview** function to render a figure of any of these pathways along with our DEGs

Let's see the hsa05310 Asthma pathway with our DEGs colored up: 
```{r}
pathview(gene.data=foldchanges, pathway.id="hsa05310")

```

![](hsa05310.pathview.png)


> Q. Can you render and insert here the pathway for Type I diabetes and Graft-versus host disease?

```{r}
pathview(gene.data=foldchanges, pathway.id="hsa05332")
```

![](hsa05332.pathview.png)


```{r}
pathview(gene.data=foldchanges, pathway.id="hsa04940")
```
![](hsa04940.pathview.png)




